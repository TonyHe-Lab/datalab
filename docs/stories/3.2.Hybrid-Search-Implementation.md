---
title: "Story 3.2: Hybrid Search Implementation (SQL with RRF Logic)"
epic: 3
story: 2
status: approved
---

## Story

**As a** search engineer,
**I want** hybrid search implementation combining semantic and keyword search with RRF fusion,
**so that** users can find relevant medical work orders using both semantic understanding and keyword matching.

## Acceptance Criteria

AC-1: Semantic search implementation
- Validation steps: Implement vector similarity search using pgvector embeddings
- Pass condition: Can find similar cases based on semantic meaning with configurable threshold

AC-2: Keyword search implementation
- Validation steps: Implement PostgreSQL full-text search with BM25 ranking
- Pass condition: Can find cases containing specific keywords with relevance scoring

AC-3: RRF (Reciprocal Rank Fusion) algorithm
- Validation steps: Implement RRF logic to combine semantic and keyword search results
- Pass condition: Results from both methods are properly fused with weighted scores

AC-4: Search API endpoint
- Validation steps: Create RESTful API endpoint for hybrid search
- Pass condition: API accepts search queries and returns ranked results with metadata

AC-5: Performance optimization
- Validation steps: Implement query optimization and result caching
- Pass condition: Search queries complete within acceptable latency limits

## Tasks / Subtasks

- [ ] Task 1: Semantic search implementation (AC: 1)
  - [ ] Create vector similarity query using pgvector operators
  - [ ] Implement embedding generation for search queries
  - [ ] Add similarity threshold configuration
  - [ ] Create semantic search service module

- [ ] Task 2: Keyword search implementation (AC: 2)
  - [ ] Configure PostgreSQL full-text search indexes
  - [ ] Implement BM25 ranking queries
  - [ ] Add search query preprocessing (stemming, stopwords)
  - [ ] Create keyword search service module

- [ ] Task 3: RRF fusion algorithm (AC: 3)
  - [ ] Implement RRF score calculation logic
  - [ ] Create result merging and deduplication
  - [ ] Add configurable weighting parameters
  - [ ] Test fusion with various query types

- [ ] Task 4: Search API endpoint (AC: 4)
  - [ ] Create `/api/search` endpoint with request validation
  - [ ] Implement search service orchestration
  - [ ] Add pagination and filtering support
  - [ ] Create response serialization

- [ ] Task 5: Performance optimization (AC: 5)
  - [ ] Implement query result caching
  - [ ] Add search query optimization
  - [ ] Create database query performance monitoring
  - [ ] Add search analytics tracking

- [ ] Task 6: Testing and validation (AC: 1,2,3,4,5)
  - [ ] Create unit tests for search algorithms
  - [ ] Create integration tests for search endpoints
  - [ ] Test with realistic medical work order data
  - [ ] Validate search quality metrics

## Dev Notes

### Previous Story Insights
- Story 3.1: FastAPI skeleton and async database connection established [Source: docs/stories/3.1.FastAPI-Skeleton-Async-DB-Connection.md]
- Story 2.4: Database connection patterns and performance considerations [Source: docs/stories/2.4.Backfill-Tool-Historical-Data-Processing.md]
- Story 2.3: Azure OpenAI embedding generation for semantic search [Source: docs/stories/2.3.Azure-OpenAI-Integration-PII-Scrubbing.md]

### Data Models
From architecture.md data model section:
- `semantic_embeddings` table with `vector` column (1536 dim, HNSW Index) [Source: docs/architecture.md#5-数据模型-data-model]
- `notification_text` table with `noti_text` column for full-text search [Source: docs/architecture.md#5-数据模型-data-model]
- `ai_extracted_data` table for enriched search results [Source: docs/architecture.md#5-数据模型-data-model]
- Field naming convention: `noti_` prefix for notification fields [Source: docs/architecture.md#5-数据模型-data-model]

### API Specifications
From architecture.md technical implementations:
- Hybrid search SQL logic with RRF fusion [Source: docs/architecture.md#42-混合搜索算法-hybrid-search]
- Example SQL query structure provided [Source: docs/architecture.md#42-混合搜索算法-hybrid-search]
- Semantic search: `SELECT log_id, 1/(60 + RANK() OVER (ORDER BY vector <=> :query_vec)) as score` [Source: docs/architecture.md#42-混合搜索算法-hybrid-search]
- Keyword search: `SELECT notification_id, 1/(60 + RANK() OVER (ORDER BY ts_rank(...))) as score` [Source: docs/architecture.md#42-混合搜索算法-hybrid-search]
- RRF fusion: `SELECT COALESCE(s.log_id, k.log_id) as id, (COALESCE(s.score, 0) + COALESCE(k.score, 0)) as final_score` [Source: docs/architecture.md#42-混合搜索算法-hybrid-search]

### File Locations
Based on project structure:
- `src/backend/services/search_service.py` - Hybrid search service implementation
- `src/backend/services/semantic_search.py` - Semantic search module
- `src/backend/services/keyword_search.py` - Keyword search module
- `src/backend/api/search.py` - Search API endpoints
- `src/backend/core/rrf_fusion.py` - RRF algorithm implementation
- `tests/backend/services/test_search_service.py` - Search service tests
- `tests/backend/api/test_search.py` - Search API tests

### Testing Requirements
From architecture.md testing strategy:
- Unit tests for search algorithms
- Integration tests for search endpoints
- Performance tests for search queries
- Search quality validation tests
- Test with realistic medical terminology

### Technical Constraints
- PostgreSQL 18 with pgvector extension on Windows host [Source: docs/architecture.md#32-数据存储-windows-host]
- 1536-dimensional embeddings from Azure OpenAI [Source: docs/architecture.md#5-数据模型-data-model]
- HNSW index for vector similarity search [Source: docs/architecture.md#5-数据模型-data-model]
- Full-text search with English language support [Source: docs/architecture.md#42-混合搜索算法-hybrid-search]
- RRF algorithm with configurable parameters [Source: docs/architecture.md#42-混合搜索算法-hybrid-search]

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-12-28 | 1.0 | Initial story creation | Scrum Master |
